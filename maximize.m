(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
maxIterations=Automatic;


(* ::Input::Initialization:: *)
ClearAll[optimize];
optimize::method="I cannot recognize an optimization method named \"`1`\".";
optimize["methods"]={"Automatic",{"DifferentialEvolution","CrossProbability"->0.5,"InitialPoints"->Automatic,"PenaltyFunction"->Automatic,"PostProcess"->Automatic,"RandomSeed"->0,"ScalingFactor"->0.6,"SearchPoints"->Automatic,"Tolerance"->0.001},"NelderMead","SimulatedAnnealing","RandomSearch",{"ParticleSwarmOptimization","nparts"->32,"bndLo"->-10,"bndUp"->10,"niter"->100,"r"->1,"RandomSeed"->0}};
optimize::usage="optimize[f,x,method] is a wrapper that involves several separated optimization methods. f must be defined as a pure function in the sense f=func[Sequence@@#]&. x is a list of uknowns {x1,x2,...,xn}. Implemented methods for now include Mathematica's DifferentialEvolution, SimulatedAnnealing, RandomSearch, NelderMead. ParticleSwarmOptimization is an external method (PSO).";
optimize[f_,x_,method_:"DifferentialEvolution"]:=Module[{f1,sol,m},

objectivecounter=0; (*Initialize calls to 0*)

m=If[StringQ@method,method,method[[1]]];

Switch[m,
"Automatic",
	sol=NMaximize[f[x],x,MaxIterations->maxIterations,Method->method,StepMonitor:> Sow[x]],
"DifferentialEvolution",
	sol=NMaximize[f[x],x,MaxIterations->maxIterations,Method->method,StepMonitor:> Sow[x]],
"SimulatedAnnealing",
	sol=NMaximize[f[x],x,MaxIterations->maxIterations,Method->method,StepMonitor:> Sow[x]],
"RandomSearch",
	sol=NMaximize[f[x],x,MaxIterations->maxIterations,Method->method,StepMonitor:> Sow[x]],
"NelderMead",
	sol=NMaximize[f[x],x,MaxIterations->maxIterations,Method->method,StepMonitor:> Sow[x]],

"ParticleSwarmOptimization",
f1=Function[{x1},-f[x1]];
sol=If[StringQ@method,
PSO[f1,x],
PSO[f1,x,Sequence@@(method[[2;;All]])]
];
sol[[1]]=-sol[[1]];sol[[2]]=Thread[x->sol[[2]]],

_,Message[optimize::method,method];sol=0];

sol
]


(* ::Input::Initialization:: *)
ClearAll[maximize];
maximize::usage="maximize[dataArray_,noAttr_,method_:\"DifferentialEvolution\",permuteinvariant_:False,printflag_:False] is MSE specific and uses the optimize function. It uses objective function (that counts the number of satisfied inequalities). It returns a list {max,{x1->value1, x2->value2, ...}} where max is the maximum number of satisfied inequalities found and the solution {x1,x2,...}";
maximize[dataArray_,noAttr_,method_:"DifferentialEvolution",permuteinvariant_:False,printflag_:False]:=Module[{sol,x,
order,invariantdataArray,reverseorder},

If[!(Developer`PackedArrayQ[dataArray]),Print["WARNING - The dataArray IS NOT a packed array. Calculations will be severely slowed down."]];

x=Cx[noAttr-1];

If[permuteinvariant,
order=Ordering[(*Smaller deviation first*)
N[StandardDeviation/@(Transpose@dataArray[[All,2;;-1]])]
];
invariantdataArray=dataArray[[All,Prepend[order+1,1]]];(*invariantdataArray remains packed*)

sol=optimize[objective[invariantdataArray,Sequence@@#]&,x,method];

sol={sol[[1]],x/.sol[[2]]};

reverseorder=SortBy[Transpose[{sol[[2]],order}],Last][[All,1]];

sol={sol[[1]],reverseorder};

If[printflag,Print["order=",order,"  reverse order=",reverseorder]]
,

sol=optimize[objective[dataArray,Sequence@@#]&,x,method];

sol={sol[[1]],x/.sol[[2]]}
];

If[printflag,
Print["Method "<>ToString[method]];
Print["Completed : ",
{sol[[1]],Thread[header[[5;;(5+noAttr-2)]]->sol[[2]]]},
"\nSatisfied Ineqs Analysis:\n ",
Grid[objectiveV[dataArray,Sequence@@(sol[[2]])],Frame->All]
]
];
sol
]

