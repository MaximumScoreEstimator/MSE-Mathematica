(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
ClearAll[store,restore];
store::usage="store[] is used for storing the lists payoffMatrix and matchMatrix before they are modified. In that case they can restored later (with the restore[] command).";
store[printflag_:True]:=Module[{},
storedpayoffMatrix=payoffMatrix;
storedmatchMatrix=matchMatrix;
currentquotas=quotas@matchMatrix;
Print[" storedpayoffMatrix=payoffMatrix\n storedmatchMatrix=matchMatrix\n currentquotas=quotas@matchMatrix"];
];
restore::usage="restore[] is used to restore the lists payoffMatrix and matchMatrix mate to their original (when the last store[] command was used)";
restore[printflag_:False]:=Module[{},
payoffMatrix=storedpayoffMatrix;
matchMatrix=storedmatchMatrix;
currentquotas=quotas@matchMatrix;
If[printflag,Print[" payoffMatrix and matchMatrix have been restored!"]];
];


(* ::Input::Initialization:: *)
ClearAll[removeU];
removeU::usage="removeU[m_,u_List,match_:False] removes from the payoffMatrix's market m the upstreams that are included in the list u. If the match flag is set to True then they are removed also from the matchMatrix. This is preferred on the precomputed case where we do not have to change noU and noD lists.";
removeU[m_,u_List,match_:False]:=Block[{keep},
keep=Complement[Range[Dimensions[payoffMatrix[[m]]][[1]]],u];
payoffMatrix[[m]]=payoffMatrix[[m,keep]];
currentquotas[[1,m]]=currentquotas[[1,m,keep]];
If[match,matchMatrix[[m]]=matchMatrix[[m,keep]]];
];


(* ::Input::Initialization:: *)
ClearAll[removeD];
removeD::usage="removeD[m_,d_List,match_:False] removes from the payoffMatrix's market m the downstreams that are included in the list d. If the match flag is set to True then they are removed also from the matchMatrix. This is preferred on the precomputed case where we do not have to change noU and noD lists.";
removeD[m_,d_List,match_:False]:=Block[{keep},
keep=Complement[Range[Dimensions[payoffMatrix[[m]]][[2]]],d];
payoffMatrix[[m]]=payoffMatrix[[m,All,keep]];
currentquotas[[2,m]]=currentquotas[[2,m,keep]];
If[match,matchMatrix[[m]]=matchMatrix[[m,All,keep]]];
];


(* ::Input::Initialization:: *)
ClearAll[removeUD];
removeUD::usage="removeUD[m_,u_List,d_List,match_:False] combines removeU and removeD in one step";
removeUD[m_,u_List,d_List,match_:False]:=(
removeU[m,u,match];
removeD[m,d,match];
)


(* ::Input::Initialization:: *)
ClearAll[payoffMatrix2Positive];
SetAttributes[payoffMatrix2Positive,HoldFirst];
payoffMatrix2Positive::usage="payoffMatrix2Positive[offset,payoffMatrix,epsilon_:0,sameoffset_:False] returns a list of matrices of positive elements. The offset variable is set accordingly. If the sameoffset flag is set to True then the offset equals the minimum element in the entire payoffMatrix.";
payoffMatrix2Positive[offset_,payoffMatrix_?(And@@(NumericQ/@Flatten@#)&),epsilon_:0,sameoffset_:False]:=Block[{min},
offset=Min/@payoffMatrix;
If[sameoffset,min=Min@offset;offset=Table[min,{Length@payoffMatrix}]];
payoffMatrix-offset+epsilon
];



