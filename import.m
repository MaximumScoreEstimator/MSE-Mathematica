(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
ClearAll[readHeader];
readHeader::usage="readHeader[file] opens the file and reads the first line. A list of string records is returned.\nIt is assumed that the file containes only test and the first line involves tabs or commas to separate records"; 
readHeader[file_String?FileExistsQ]:=Module[{str=OpenRead[file],header},
header=StringSplit[StringReplace[
Read[str,Record,RecordSeparators->{"\n"}],
"\t"->","],","];
Close[str];header];


(* ::Input::Initialization:: *)
ClearAll[readYourCSV]; (*n is the number of columns to read*)
readYourCSV::usage=
"readYourCSV[file,n] opens and reads a CSV or TSV file assuming that the number of columns equals n. Remark: All fields must be numeric - the header must be manually removed afterwards or translated to String with the ToString command";
readYourCSV[file_String?FileExistsQ,n_Integer]:=Module[{str=OpenRead[file],data},data=ReadList[str,Table[Record,{n}],RecordSeparators->{"\t",",","\n"}];
Close[str];
ReleaseHold[ToExpression[data,InputForm,Hold]/.{Plus[Times[x_,E|e],y_]:>x*10^y}]];


(* ::Input::Initialization:: *)
ClearAll[importCSV];
importCSV::usage=
"importCSV[file] opens and reads a CSV or TSV file assuming that each row contains the same number of records. Remark: All fields must be numeric - the header must be manually removed afterwards or translated to String with the ToString command";
importCSV[file_String?FileExistsQ]:=readYourCSV[file,Length@readHeader[file]];


(* ::Input::Initialization:: *)
(*General memory-efficient solution*)
(*http://stackoverflow.com/a/7527064/2468683*)
Clear[readTable];
readTable::usage="readTable[file] open and reads tabular data in a memory efficient way";
readTable[file_String?FileExistsQ,chunkSize_: 1000]:=Module[{str,stream,dataChunk,result,linkedList,add},SetAttributes[linkedList,HoldAllComplete];
add[ll_,value_]:=linkedList[ll,value];
stream=StringToStream[Import[file,"String"]];
Internal`WithLocalSettings[Null,(*main code*)result=linkedList[];
While[dataChunk=!={},dataChunk=ImportString[StringJoin[Riffle[ReadList[stream,"String",chunkSize],"\n"]],"Table"];
result=add[result,dataChunk];];
result=Flatten[result,Infinity,linkedList],(*clean-up*)Close[stream]];
Join@@result]


(* ::Input::Initialization:: *)
(*http://mathematica.stackexchange.com/questions/6144/looking-for-longest-common-substring-solution/6376#6376*)
(*Get[directory<>"SimpleJavaReloader.m"]*)


(* ::Input::Initialization:: *)
(*
If[$OperatingSystem\[Equal]"Windows",
JCompileLoad["public class DoubleParser{
   public static double[] parseDouble(String[] strdub){
      double[] res = new double[strdub.length];
      int i = 0;
      for(;i < strdub.length;i++){
         try{
            res[i]= Double.parseDouble(strdub[i]);
         } catch (NumberFormatException e){
            res[i] = 0;
         }
      }
      return res;
   }
}"]
]
*)


(* ::Input::Initialization:: *)
(*
ClearAll[importDoubleCSV];
Options[importDoubleCSV]={"Headers"\[Rule]True};
importDoubleCSV::usage="importDoubleCSV[file] is a Java-based solution for efficient importing, pretty fast but valid only when all your columns are numerical (double) values. Note that Java parsing code adopts a convention to replace all non-parsable strings with zeros. It is possible to improve on this, by returning also the positions of non-parsable strings, separately. Note also that the UTF-8 encoding is implicitly assumed";
importDoubleCSV[file_String?FileExistsQ,opts:OptionsPattern[]]:=With[{fn=If[TrueQ[OptionValue["Headers"]],Rest,Identity]},Transpose[DoubleParser`parseDouble/@Transpose[DeleteCases[StringSplit[fn[StringSplit[FromCharacterCode[BinaryReadList[file]],"\n"]],{"\t",","}],{s_String/;StringMatchQ[s,Whitespace]}]]]]
*)


(* ::Input::Initialization:: *)
ClearAll[import];
import::usage="{noM,no,u,noAttr}=import[filename,\"stream\"] to load an upstream.\r
{noM,no,d,noAttr}=import[filename,\"stream\"] to load a downstream.\r
imports a file .xls or .xlsx or a tab delimited file .dat that includes data corresponding to an upstream (u) or downstream (d).\r
Datafiles consist of rows in the form {noM,no,attr1,attr2,...,attrn,noAttr}.\r
In the case of .xls or .xlsx files multiple sheets are joined - for example if each market resides in its own excel sheet.\r
__________________________________________________________________________________________________\r
{header,noM,noU,noD,noAttr,distanceMatrices,matchMatrix,mate}=import[filename_,\"precomp\",printflag_:False]\r
imports a file .xls or .xlsx or a tab delimited file .dat that includes precomputed matched data (distances between same attributes are already computed).\r
Datafiles consists of rows in the form {m,u,d,u1,d1,u2,d2,...,un,dn,matched (0 or 1)}.\r
In the case of .xls or .xlsx files multiple sheets are joined - for example if each market resides in its own excel sheet.\r";


(* ::Input::Initialization:: *)
import[filename_,"stream",numeric_:True]:=Module[{data,noM,no,attributes,noAttr},
If[
MemberQ[{"xls","xlsx"},FileExtension[filename]],
data=Import[filename];
data=Flatten[data[[All,2;;All]],1]
,
data=If[numeric,importCSV[filename],Import[filename]];
data=data[[2;;All]]
];
noM=Length@Union@data[[All,1]];
no=(Transpose@Tally@data[[All,1]])[[2]];
attributes=(GatherBy[data,First])[[All,All,3;;All]];
noAttr=(Dimensions@attributes[[1,2]])[[1]];
{noM,no,attributes,noAttr}]


(* ::Input::Initialization:: *)
(*Header assumed inside the file*)
import[filename_,"precomp",printflag_:False,numeric_:True]:=Module[{data,header,noAttr,matchMatrix,mate,noM,noU,noD,distanceMatrices},
(*Importing data - header is excluded*)
If[
MemberQ[{"xls","xlsx"},FileExtension[filename]],
data=Import[filename];header=data[[1,1]];
data=Flatten[data[[All,2;;All]],1];
data=Sort[ Join[IntegerPart[#[[{1,2,3}]]],#[[4;;-2]],{IntegerPart[#[[-1]]]}]&/@data](*Sort is m,u,d*)
,
data =If[numeric,
Switch[MSEresources,
"Speed",importCSV[filename],
"Memory",readTable[filename](*importDoubleCSV not active*)
]
,Import[filename]];(*141203 Replaced Import with importCSV*)
header=ToString/@data[[1]];
data=Sort[data[[2;;All]]](*Sort is m,u,d*)
];
(*Calculating number of attributes*)
noAttr=Length[First@data]-3-1;
(*150606
(*Formating the mate*)
mate=Transpose/@
Map[{{#[[1,1]]},#[[All,2]]}&,
GatherBy[Select[data,Last@#\[Equal]1&][[All,1;;3]],{First,#[[2]]&}][[All,All,All,2;;3]]
,{2}];
mate=IntegerPart@mate;(*Some times the mate column has reounded values 1., 2. etc*)
BUG --> When no matches axist for some upstreams  - FIXED below calling Cmate
*)
(*Creating a 3 dimensional list of variable length to access attributes by {market,upstream,downstream}*)
data=GatherBy[#,#[[2]]&]&/@GatherBy[data,First];
(*Calculating Match Matrix*)
matchMatrix=IntegerPart@data[[All,All,All,-1]];
mate=Cmate[matchMatrix]; (*Substite withe the Cmate expression ? *)
(*Calculating number of markets*)
noM=Length[data];
(*Calculating number of upstreams and down streams in each market*)
{noU,noD}=Module[{l},l=Map[Length,data,{2}];{Length/@l,l[[All,1]]}];
(*Define distance matrices (dropping market,upsteam and downstream indexes - they can be accessed using Part)*)
distanceMatrices=Table[
data[[m,u,d]][[4;;-2]]
,{m,noM},{u,noU[[m]]},{d,noD[[m]]}];
If[printflag,Print["header = ",header,"\ndata = ",data,"\nNumber of upstreams per market = ",noU,"\nNumber of downstreams per market = ",noD,"\nNumber of attributes = ",noAttr,"\nDistance Matrices = ",distanceMatrices,"\nmatchMatrix = ",matchMatrix,"\nmate = ",mate]];
{header,noM,noU,noD,noAttr,distanceMatrices,matchMatrix,mate}
]



